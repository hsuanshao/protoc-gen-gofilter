package main

import (
	"flag"
	"fmt"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"

	// Import the extension defined in this project
	pb "github.com/hsuanshao/protoc-gen-gofilter/proto/filter"
)

// Define the Import Path of the Runtime Library
const runtimePackage = protogen.GoImportPath("github.com/hsuanshao/protoc-gen-gofilter/entity/filter")

func main() {
	var flags flag.FlagSet
	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	if !hasFilter(file.Messages) {
		return
	}
	filename := file.GeneratedFilenamePrefix + "_filter.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-gofilter. DO NOT EDIT.")
	g.P("package ", file.GoPackageName)
	g.P()

	// Automatically import Runtime Library
	registryIdent := runtimePackage.Ident("Registry")
	bitSetIdent := runtimePackage.Ident("BitSet")

	// Iterate through Messages
	for _, message := range file.Messages {
		generateMessageLogic(g, message, registryIdent, bitSetIdent)
	}
}

func generateMessageLogic(g *protogen.GeneratedFile, message *protogen.Message, regIdent, setIdent protogen.GoIdent) {
	type fieldInfo struct {
		goName   string
		permID   string
		zeroStmt string
	}
	var targetFields []fieldInfo

	for _, field := range message.Fields {
		opts, ok := field.Desc.Options().(*descriptorpb.FieldOptions)
		if !ok {
			continue
		}
		// Parse Extension: filter.apply
		if !proto.HasExtension(opts, pb.E_Apply) {
			continue
		}
		permID := proto.GetExtension(opts, pb.E_Apply).(string)

		targetFields = append(targetFields, fieldInfo{
			goName:   field.GoName,
			permID:   permID,
			zeroStmt: buildZeroValueStmt(field),
		})
	}

	if len(targetFields) == 0 {
		return
	}

	msgName := message.GoIdent.GoName

	// 1. Init Vars
	for _, f := range targetFields {
		varName := fmt.Sprintf("_PermIdx_%s_%s", msgName, f.goName)
		g.P("var ", varName, " int")
	}
	g.P()

	// 2. Init Func
	g.P("func init() {")
	for _, f := range targetFields {
		varName := fmt.Sprintf("_PermIdx_%s_%s", msgName, f.goName)
		g.P(varName, " = ", regIdent, `.Register("`, f.permID, `")`)
	}
	g.P("}")
	g.P()

	// 3. Filter Method
	g.P("func (x *", msgName, ") FilterFields(mask ", setIdent, ") {")
	for _, f := range targetFields {
		varName := fmt.Sprintf("_PermIdx_%s_%s", msgName, f.goName)
		g.P("if !mask.Has(", varName, ") {")
		g.P(f.zeroStmt)
		g.P("}")
	}
	g.P("}")
	g.P()
}

func buildZeroValueStmt(field *protogen.Field) string {
	fieldName := "x." + field.GoName
	if field.Desc.IsList() || field.Desc.IsMap() || field.Desc.HasOptionalKeyword() || field.Oneof != nil {
		return fieldName + " = nil"
	}
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return fieldName + " = false"
	case protoreflect.StringKind, protoreflect.BytesKind:
		return fieldName + " = \"\""
	case protoreflect.MessageKind, protoreflect.GroupKind:
		return fieldName + " = nil"
	default:
		return fieldName + " = 0"
	}
}

func hasFilter(messages []*protogen.Message) bool {
	for _, message := range messages {
		for _, field := range message.Fields {
			opts, ok := field.Desc.Options().(*descriptorpb.FieldOptions)
			if !ok {
				continue
			}
			if proto.HasExtension(opts, pb.E_Apply) {
				return true
			}
		}
		if hasFilter(message.Messages) {
			return true
		}
	}
	return false
}
